//
//  EverFilterExporter.m
//  Ever FilterGenerator
//
//  Created by Simon CORSIN on 5/21/13.
//  Copyright (c) 2013 com.ever. All rights reserved.
//

#import "EverFilterExporter.h"
#import "EverFilters.h"
#import <objc/runtime.h>

@implementation EverFilterExporter

+ (NSString*) indent:(NSString*)input {
    NSMutableString * output = [[NSMutableString alloc] initWithString:input];

    int indentCount = 0;
    BOOL shouldIndent = NO;
    for (NSUInteger index = 0; index < [output length]; index++) {
        unichar currentChar = [output characterAtIndex:index];
        
        switch (currentChar) {
            case ';':
                [output insertString:@"\n" atIndex:index + 1];
                break;
            case '{':
                indentCount++;
                [output insertString:@"\n" atIndex:index + 1];
                break;
            case '}':
                indentCount--;
                // We indented too much
                if (index > 0 && [output characterAtIndex:index - 1] == '\t') {
                    [output deleteCharactersInRange:NSMakeRange(index - 1, 1)];
                    index--;
                }
                [output insertString:@"\n" atIndex:index + 1];
                break;
            case '\n':
                shouldIndent = YES;
                [output insertString:[@"" stringByPaddingToLength:indentCount withString:@"\t" startingAtIndex:0] atIndex:index + 1];
            break;
            default:
                break;
        }
    }
    
    return output;
}

+ (NSString*) getAttributedNameAtIndex:(NSInteger)index {
    NSString * attributedName = [[NSString alloc] initWithFormat:@"filter%ld", index];

    return attributedName;
}

+ (NSString*) generateHeader:(NSArray*)pipeline className:(NSString*)className {
    NSMutableString * output = [[NSMutableString alloc] init];
    
    [output appendFormat:@"// Code generated by Ever FilterGenerator\n\n"];
    [output appendFormat:@"#import <Foundation/Foundation.h>\n"];
    [output appendFormat:@"#import <GPUImage/GPUImage.h>\n"];
    [output appendFormat:@"\n@interface %@ : GPUImageFilterGroup {", className];
    
    // Declare variables
    NSInteger index = 0;
    for (EverFilter * everFilter in pipeline) {
        NSString * attributedName = [EverFilterExporter getAttributedNameAtIndex:index];

        NSString * variables = [everFilter getObjCVariables:attributedName];
        if (variables != nil) {
            [output appendFormat:@"%@", variables];
        }
        index++;
    }
    
    [output appendFormat:@"}\n@end"];
    
    return [EverFilterExporter indent:output];
}

+ (NSString*) generateClass:(NSArray*)pipeline className:(NSString*)className {
    NSMutableString * output = [[NSMutableString alloc] init];
    
    [output appendFormat:@"// Code generated by Ever FilterGenerator\n\n"];
    [output appendFormat:@"#import \"%@.h\"\n", className];
    [output appendFormat:@"\n@implementation %@\n", className];
    [output appendFormat:@"\n- (id) init { self = [super init]; if (self) {"];
    
    // Constructor
    int index = 0;
    NSString * lastFilterName = nil;
    for (EverFilter * everFilter in pipeline) {
        const char * type = class_getName([everFilter.filter class]);
        NSString * attributedName = [[NSString alloc] initWithFormat:@"filter%d", index];
        [output appendFormat:@"%s * %@ = [[%s alloc] init];", type, attributedName, type];
        
        // Getting possible additionals configurations
        NSString * configurations = [everFilter getObjCParameters:attributedName];
        if (configurations != nil) {
            [output appendFormat:@"{%@}", configurations];
        }
        
        [output appendFormat:@"[self addFilter:%@];", attributedName];
        if (lastFilterName != nil) {
            [output appendFormat:@"[%@ addTarget:%@ atTextureLocation:0];", lastFilterName, attributedName];
        }
        lastFilterName = attributedName;
        index++;
    }
    
    [output appendFormat:@"self.initialFilters = [[NSArray alloc] initWithObjects:%@, nil];", [EverFilterExporter getAttributedNameAtIndex:0]];
    [output appendFormat:@"self.terminalFilter = %@;", [EverFilterExporter getAttributedNameAtIndex:[pipeline count] - 1]];
    
    [output appendFormat:@"}return self;}"];
    
    // Image Capture
    [output appendFormat:@"\n- (void) prepareForImageCapture {"];
    
    index = 0;
    for (EverFilter * everFilter in pipeline) {
        NSString * attributedName = [EverFilterExporter getAttributedNameAtIndex:index];
        
        NSString * configurations = [everFilter getObjCPrepareForCapture:attributedName];
        if (configurations != nil) {
            [output appendFormat:@"%@", configurations];
        }
        index++;
    }
    
    [output appendFormat:@"[super prepareForImageCapture];}"];
    
    
    [output appendFormat:@"\n@end"];
    
    return [EverFilterExporter indent:output];
}

+ (BOOL) exportFilters:(NSArray *)pipeline outputFile:(NSURL *)outputFile {
    NSString * className = [[[outputFile path] lastPathComponent] stringByDeletingPathExtension];
    NSString * header = [EverFilterExporter generateHeader:pipeline className:className];
    NSString * class = [EverFilterExporter generateClass:pipeline className:className];
    
    NSLog(@"=================================\n%@", header);
    NSLog(@"=================================\n%@", class);
    
    BOOL success = [header writeToFile:[outputFile.path stringByAppendingString:@".h"] atomically:YES encoding:NSASCIIStringEncoding error:nil];
    success &= [class writeToFile:[outputFile.path stringByAppendingString:@".m"] atomically:YES encoding:NSASCIIStringEncoding error:nil];
    
    return success;
}

+ (BOOL) exportFiltersCSharp:(NSArray *)pipeline outputFile:(NSURL *)outputFile {
    NSMutableString * output = [[NSMutableString alloc] init];
    
    NSString * className = [[[outputFile path] lastPathComponent] stringByDeletingPathExtension];
    
    [output appendString:@"using System;"];
    [output appendString:@"using GPUImageBindings;using MonoTouch.UIKit;\n"];
    [output appendString:@"namespace CameraIphone {"];
    [output appendFormat:@"public class %@ : PhotoEffect {\n", className];
    [output appendFormat:@"public static readonly string NAME = \"%@\";\n", className];
    [output appendFormat:@"public %@() : base(NAME) {", className];
    [output appendFormat:@"}\n"];
    [output appendFormat:@"public override GPUImageFilter createFilter() {"];
    [output appendFormat:@"GPUImageFilterGroup group = new GPUImageFilterGroup();"];
    
    NSMutableArray * filterArray = [[NSMutableArray alloc] init];
    int currentFilterIndex = 0;
    for (EverFilter * everFilter in pipeline) {
        const char * filterType = class_getName([everFilter.filter class]);
        NSString * filterName = [NSString stringWithFormat:@"filter%d", currentFilterIndex];
        [output appendFormat:@"%s %@ = new %s();", filterType, filterName, filterType];
        NSString * parameters = [everFilter getCSharpParameters:filterName];
        if (parameters != nil) {
            [output appendString:parameters];
        }
        currentFilterIndex++;
        [filterArray addObject:filterName];
    }
    
    for (NSString * filterName in filterArray) {
        [output appendFormat:@"this.attachFilter(group, %@);", filterName];
    }
    
    [output appendFormat:@""];
    [output appendFormat:@"return group;"];
    [output appendFormat:@"}\n"];
    [output appendFormat:@"}"];
    [output appendFormat:@"}"];
    
    [[EverFilterExporter indent:output] writeToURL:outputFile atomically:YES encoding:NSASCIIStringEncoding error:nil];
    
    NSLog(@"%@", [EverFilterExporter indent:output]);
    
    return NO;
}

@end
